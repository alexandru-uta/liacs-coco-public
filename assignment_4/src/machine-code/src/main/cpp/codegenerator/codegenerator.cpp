#include "codegenerator.h"
#include <iostream>
#include <utility.h>

// Generates a header
void CodeGenerator::generate_header() {
    out << "# Output generated by the CoCo compiler\n";
}

// Generates the declarations for the global variables
void CodeGenerator::generate_global_decls(SymbolTable& table) {
    for (auto symbol : table.getGlobals()) {
        globals.insert(symbol.first, util::to_iopt(symbol.second->getReturnType()));
    }

    globals.generate_data_segment();
}

// Takes an IntermediateCode object and emits x86-64 assembly instructions
void CodeGenerator::generate_code(SymbolTable& table, IntermediateCode& inputCode, FlowGraph& graph) {
    //TODO: implement me!
}

// Generates a trailer
void CodeGenerator::generate_trailer() {
    out <<  ".LC0:\n"
            "\t.string \"%d\"\n"
            "\t.globl readinteger\n"
            "readinteger:\n"
            "\tpushq\t%rbp\n"               // push rbp to stack
            "\tmovq\t%rsp, %rbp\n"          // move rbp to current location of rsp (rbp = rsp)
            "\tsubq\t$16, %rsp\n"           // extend the stack with 16 bytes (16 bytes aligned)
            "\tleaq\t-12(%rbp), %rsi\n"     // second argument: local variable at rbp - 12
            "\tleaq\t.LC0(%rip), %rdi\n"    // first argument: string format "%d"
            "\tcall\tscanf\n"               // call scanf
            "\tmovl\t-12(%rbp), %eax\n"     // return value is local variable, which saved the read integer
            "\tmovq\t%rbp, %rsp\n"          // move rsp back to its previous location
            "\tpopq\t%rbp\n"                // pop rbp from the stack
            "\tret\n";                      // return to caller (rbp)

    out <<  ".LC1:\n"
            "\t.string \"%d\\n\"\n"
            "\t.globl writeinteger\n"       //Note: writeinteger has no local variables,
            "writeinteger:\n"               //therefore stack does not need to be extended
            "\tpushq\t%rbp\n"               // push rbp to stack
            "\tmovl\t%edi, %esi\n"          // 1st argument writeinteger is saved to %rdi, we use it as 2nd argument
            "\tleaq\t.LC1(%rip), %rdi\n"    // 1st argument to printf
            "\tcall\tprintf\n"              // call printf
            "\tpopq\t%rbp\n"                // pop rbp from stack
            "\tret\n";                      // return to caller

    out <<  ".LC2:\n"
            "\t.string \"%u\"\n"
            "\t.globl readunsigned\n"
            "readunsigned:\n"
            "\tpushq\t%rbp\n"               // push rbp to stack
            "\tmovq\t%rsp, %rbp\n"          // move rbp to current location of rsp (rbp = rsp)
            "\tsubq\t$16, %rsp\n"           // extend the stack with 16 bytes (16 bytes aligned)
            "\tleaq\t-12(%rbp), %rsi\n"     // second argument: local variable at rbp - 12
            "\tleaq\t.LC2(%rip), %rdi\n"    // first argument: string format "%d"
            "\tcall\tscanf\n"               // call scanf
            "\tmovl\t-12(%rbp), %eax\n"     // return value is local variable, which saved the read integer
            "\tmovq\t%rbp, %rsp\n"          // move rsp back to its previous location
            "\tpopq\t%rbp\n"                // pop rbp from the stack
            "\tret\n";                      // return to caller (rbp)

    out <<  ".LC3:\n"
            "\t.string \"%u\\n\"\n"
            "\t.globl writeunsigned\n"      //Note: writeunsigned has no local variables,
            "writeunsigned:\n"              //therefore stack does not need to be extended
            "\tpushq\t%rbp\n"               // push rbp to stack
            "\tmovl\t%edi, %esi\n"          // 1st argument writeinteger is saved to %rdi, we use it as 2nd argument
            "\tleaq\t.LC3(%rip), %rdi\n"    // 1st argument to printf
            "\tcall\tprintf\n"              // call printf
            "\tpopq\t%rbp\n"                // pop rbp from stack
            "\tret\n";                      // return to caller
}
